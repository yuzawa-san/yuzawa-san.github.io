  <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>NYC COVID-19 by ZIP Code</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" crossorigin=""/>
        <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js" integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==" crossorigin=""></script>
    

    <script src="https://unpkg.com/topojson@3.0.2/dist/topojson.min.js"></script>
    <script src="https://unpkg.com/chroma-js@2.1.0/chroma.min.js"></script>
    
    <script src="https://unpkg.com/@fnando/sparkline@0.3.10/dist/sparkline.js"></script>
    <style type="text/css">
      html, body {
        height: 100%;
        margin: 0;
        font: 14px sans-serif;
      }
      #content {
        width:100%;height:100%; display:flex; flex-direction:column
      }
      #controls div {
        margin:4px 8px;
        display: inline-block;
      }
      #map-container {
        width: 100%;
        height: 100%;
        flex:1;
      }
      .info { padding: 6px 8px; background: white; background: rgba(255,255,255,1.0); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; } .info h4 { margin: 0 0 5px; color: #777; }
      .legend { text-align: left; line-height: 18px; color: #555; } .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.7; }
      @media only screen and (max-width: 600px) {
        .info {font-size:10px;padding:2px;margin:2px;line-height:1em;}
        .legend i {width:5px;height:5px;}
      }
    </style>
  </head>
  <body>
    <div id="content">
      <div id="controls">
        <div><b>NYC COVID-19 by ZIP Code</b></div>
        <div>Date: <input type="date" id="end"></div>
        <div>Lookback: <select id="lookback">
            <option value="3">3 days</option>
            <option value="7">1 week</option>
            <option value="14" selected>2 weeks</option>
            <option value="30">1 month</option>
            <option value="1000">all-time</option>
          </select></div>
        <div>Metric: <select id="analysis">
          <option>newCases</option>
          <option>newCasesTrend</option>
          <option>positiveTestPercent</option>
          <option>positiveTestPercentTrend</option>
          <option>newTests</option>
          <option>newTestsTrend</option>
        </select></div>
        <div><button id="locate">Go to My Location</button></div>
      </div>
      <div id="map-container"></div>
    </div>
    <script>
      const COLORS = chroma.scale([
        "#FFFFCE",
        "#C8E8B6",
        "#84CDBB",
        "#48B6C2",
        "#3380B6",
        "#283891"
      ]);
      const GREEN_GRADIENT = chroma.scale(['green', 'white']);
      const RED_GRADIENT = chroma.scale(['white', 'red']);
      
      function prettyValue(value){
        if(!isFinite(value)) {
          return "n/a";
        }
        return value.toFixed(2);
      }
      async function getGeoData() {
        let dataResponse = await fetch('nyc.json');
        let dataJson = await dataResponse.json();
        let shapeResponse = await fetch('nyc.topo.json');
        let shapeJson = await shapeResponse.json();
        
        let minYmd = '2099-01-01';
        let maxYmd = '2000-01-01';
        let windowSize = 7;
        Object.values(dataJson).forEach(data => {
          if (!data.rows) {
            return;
          }
          data.rows = data.rows.map(row => {
            let ymd = row[0];
            let timestampMs = new Date(`${ymd}T00:00:00`).getTime();
            if (ymd < minYmd) {
              minYmd = ymd;
            }
            if (ymd > maxYmd) {
              maxYmd = ymd
            }
            let cases = row[1];
            let tests = row[2];
            return {
              ymd,
              timestampMs,
              cases,
              tests
            }
          });
          for (let i = 0; i < data.rows.length; i++) {
            let row = data.rows[i];
            const start = i - windowSize;
            const from = start >= 0 ? start : 0;
            const to = i + windowSize + 1;
            let count = 0;
            let sumTests = 0;
            let sumCases = 0;
            for (let j = from; j < to && j < data.rows.length; j += 1) {
              sumTests += data.rows[j].tests;
              sumCases += data.rows[j].cases;
              count += 1;
            }
            row.testEwma = sumTests / count;
            row.caseEwma = sumCases / count;
          }
        });
        
        
        shapeJson.objects.collection.geometries.forEach(x=> {
          let {properties} = x;
          properties.data = dataJson[properties.MODZCTA];
        });
        
        let map = L.map('map-container');
        let bglayer_Positron = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}{r}.png', {
          attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a> &copy; <a href="https://github.com/nychealth/coronavirus-data">NYC Health Department</a> | built by <a href="https://github.com/yuzawa-san">yuzawa-san</a> (not a public health expert)',
          subdomains: 'abcd',
          maxZoom: 19
        });
      
        bglayer_Positron.addTo(map);
        
        let lookbackEl = document.getElementById('lookback');
        let endEl = document.getElementById('end');
        let analysisEl = document.getElementById('analysis');
        endEl.min = minYmd;
        endEl.max = maxYmd;
        endEl.value = maxYmd;
        
        let legend = L.control({position: 'topleft'});
        let legendDiv = L.DomUtil.create('div', 'info legend');
        legend.onAdd = function (map) {
          return legendDiv;
        };
        legend.addTo(map);
      
        L.TopoJSON = L.GeoJSON.extend({
          addData: function (data) {
            let geojson, key;
            if (data.type === "Topology") {
              for (key in data.objects) {
                if (data.objects.hasOwnProperty(key)) {
                  geojson = topojson.feature(data, data.objects[key]);
                  L.GeoJSON.prototype.addData.call(this, geojson);
                }
              }
              return this;
            }
            L.GeoJSON.prototype.addData.call(this, data);
            return this;
          }
        });
        L.topoJson = function (data, options) {
          return new L.TopoJSON(data, options);
        };
        let geojson = L.topoJson(shapeJson, {
          style: function(feature){
            return {
              color: "#000",
              opacity: 1,
              weight: 1,
              fillColor: '#fff',
              fillOpacity: 0.7
            }
          }
        }).addTo(map);
        let layerBounds = geojson.getBounds();
        map.fitBounds(layerBounds);
        L.setOptions(map, {
            minZoom: map.getZoom(),
            maxBounds: layerBounds.pad(0.5)
        })
        
        let accumulate = function(rows) {
          const sum = {
            cases:0,
            tests:0
          };
          rows.forEach(x => {
            sum.cases += x.cases;
            sum.tests += x.tests;
          })
          return sum;
        };
        const regress = (x, y) => {
            const n = y.length;
            let sx = 0;
            let sy = 0;
            let sxy = 0;
            let sxx = 0;
            let syy = 0;
            for (let i = 0; i < n; i++) {
                sx += x[i];
                sy += y[i];
                sxy += x[i] * y[i];
                sxx += x[i] * x[i];
                syy += y[i] * y[i];
            }
            const mx = sx / n;
            const my = sy / n;
            const yy = n * syy - sy * sy;
            const xx = n * sxx - sx * sx;
            const xy = n * sxy - sx * sy;
            const slope = xy / xx;
            const intercept = my - slope * mx;
            const r = xy / Math.sqrt(xx * yy);
            const r2 = Math.pow(r,2);
            let sst = 0;
            for (let i = 0; i < n; i++) {
               sst += Math.pow((y[i] - my), 2);
            }
            const sse = sst - r2 * sst;
            const see = Math.sqrt(sse / (n - 2));
            const ssr = sst - sse;
            return {slope, intercept, r, r2, sse, ssr, sst, sy, sx, see};
        };
        let trend = function(extract){
          return function(rows, data, days) {
            let x = [];
            let y = [];
            for (let i = 0 ; i < rows.length; i++) {
              x.push(rows[i].timestampMs);
              y.push(extract(rows[i], data));
            }
            return regress(x,y).slope * 86400000;
          }
        }
        let analyses = {
          newCases: function(rows, data, days) {
            const sum = accumulate(rows);
            return (sum.cases / days) / data.population * 100000;
          },
          newCasesTrend: trend(function(row, data) {
            return row.caseEwma / data.population * 100000;
          }),
          positiveTestPercent: function(rows, data, days) {
            const sum = accumulate(rows);
            return sum.cases / sum.tests * 100;
          },
          positiveTestPercentTrend: trend(function(row, data) {
            return row.caseEwma / row.testEwma * 100;
          }),
          newTests: function(rows, data, days) {
            const sum = accumulate(rows);
            return (sum.tests / days) / data.population * 100000;
          },
          newTestsTrend: trend(function(row, data) {
            return row.testEwma / data.population * 100000;
          })
        }
        let selection = null;
        geojson.eachLayer(function(layer) {
          layer.on({
            click: function(e) {
              const layer = e.target;
              if (selection) {
                selection.setStyle({weight:1});
              }
              layer.setStyle({weight:3});
              layer.bringToFront();
              selection = layer;
            }
          });
        });
        
        function redraw() {
          let analysis = analysisEl.value;
          let days = parseInt(lookbackEl.value);
          let lookback = days * 86400000;
          let end = new Date(endEl.value+"T00:00:00").getTime();
          let start = end - lookback;
          let values = [];
          let modzctaValues = {};
          let modzctaTests = {};
          let modzctaCases = {};
          geojson.eachLayer(function (layer) {
            const {properties} = layer.feature;
            const modzcta = properties.MODZCTA;
            const {data} = properties;
            if (!data) {
              return;
            }
            const rows = data.rows.filter(x => {
              const {timestampMs} = x;
              return timestampMs >= start && timestampMs <= end;
            });
            let testSum = 0;
            let caseSum = 0;
            properties.testSeries = [];
            properties.caseSeries = [];
            properties.positiveRateSeries = [];
            rows.forEach(row => {
              properties.testSeries.push(row.testEwma);
              properties.caseSeries.push(row.caseEwma);
              properties.positiveRateSeries.push(row.caseEwma / row.testEwma);
            });
            const value = analyses[analysis](rows, data, days);
            if (isFinite(value)) {
              values.push(value);
              
            }
            properties.value = value;
          });
          values.sort(function(a,b){
            return a-b;
          });
          const ntiles = 10;
          let ntileBins = [];
          for (let i = 0; i < ntiles; i++) {
            let idx = Math.round(values.length * (i/ntiles));
            ntileBins.push(values[idx]);
          }
          ntileBins.push(values[values.length - 1]);
          
          let color = function(value) {
            let start = values[0];
            for (let i = 1; i < ntileBins.length; i++) {
              let ntileMax = ntileBins[i];
              if (value <= ntileMax) {
                let percentage = (value - start) / (ntileMax - start);
                return COLORS((i - 1 + percentage) / ntiles).hex();
              }
              start = ntileMax;
            }
            return 'rgba(0,0,0,0)';
          }
          
          let legendLabels = []
          for (let i = 0; i < ntileBins.length; i++) {
            let value = ntileBins[i];
            legendLabels.push('<i style="background:'+color(value)+'"></i> '+prettyValue(value));
          }
          legendDiv.innerHTML = legendLabels.join("<br>");
          
          
          geojson.eachLayer(function (layer) {
            const {properties} = layer.feature;
            const modzcta = properties.MODZCTA;
            const value = properties.value;
            layer.setStyle({fillColor: color(value)});
            if (!properties.data) {
              return;
            }
            let caseLine = document.createElement("SVG");
            caseLine.setAttribute('width',100);
            caseLine.setAttribute('height',20);
            caseLine.setAttribute('stroke','red');
            caseLine.setAttribute('fill','pink');
            caseLine.setAttribute('stroke-width',1);
            sparkline.sparkline(caseLine, properties.caseSeries || []);
            let testLine = document.createElement("SVG");
            testLine.setAttribute('width',100);
            testLine.setAttribute('height',20);
            testLine.setAttribute('stroke','blue');
            testLine.setAttribute('fill','lightblue');
            testLine.setAttribute('stroke-width',1);
            sparkline.sparkline(testLine, properties.testSeries || []);
            let positiveRateLine = document.createElement("SVG");
            positiveRateLine.setAttribute('width',100);
            positiveRateLine.setAttribute('height',20);
            positiveRateLine.setAttribute('stroke','green');
            positiveRateLine.setAttribute('fill','lightgreen');
            positiveRateLine.setAttribute('stroke-width',1);
            sparkline.sparkline(positiveRateLine, properties.positiveRateSeries || []);
            let content = '<div><b>'+properties.MODZCTA+':<br>'+properties.data.name.replace(/\//g,'<br>')+'</b><br>'+analysisEl.value+':<br>'+prettyValue(properties.value)+'<br>New Case trend:<br>'+caseLine.outerHTML+'<br>Test trend:<br>'+testLine.outerHTML+'<br>Positive Test Rate trend:<br>'+positiveRateLine.outerHTML+'</div>';
            layer.bindPopup(content);
          });
        }
        lookbackEl.onchange = redraw;
        endEl.onchange = redraw;
        analysisEl.onchange = redraw;
        redraw();
        document.getElementById('locate').onclick = function() {
          map.locate({setView: true, maxZoom: 13});
        };
      }
      
      getGeoData();
    </script>
  </body>
</html>